/* WELCOME TO MY FILE ðŸ˜Ž

The phone and phonecall datum system is intended to be highly flexible and modular; much of the logic is broken up between dozens of procs to be overridden as needed
The /phone datum essentially functions as an interface and controller between your atom and phonecalls, so you'll need to make a child tailored to your atom
You do NOT need to make a child of /datum/phonecall; it is very unlikely that you will need to, only if you can't just safely add the functionality you need to the base datum

Several key procs are blank, such as speechReceived(). This is intentional, override them to get them to work with your atom.
This does mean you can't just slap a phone datum in and call it a day; however, it does give you a lot of freedom over its behavior. See landline.dm in this folder for an example

As a note, this doesn't strictly need to be a 'phone'. This can (in theory) work with ANYTHING with a phone datum in it, such as a machine which can receive remote commands via dialpad

For consistency, I would recommend defining a typecasted var (the type of the holder atom specifically) '/ourHolder' to function almost identically to holder when you need to refer to vars/functions for said type
Things will route to the holder atom by default, but naturally you'll want to specify where speech, vapes, etc. route into and out of

See landline phones for functionality on how vaping/voltronning into phones should work; if you don't make your non-machine phone able to transmit some badass vape I give you a nicotine addiction

If you have any questions/feedback, contact @Nexusuxen on the discord or Aft2001 on the forums; hopefully I'll have remembered how this all worked! :)

Some planned features:
Expanded/improved group call functionality & TGUI control panel for managing hosted group calls
Ability to relay sounds and stop them when a call is ended or something idk
Reservable phone numbers, likely to be defined in this file and in the secret submodule
 - Possibility to include 911 as a way to call all Security phones and when one picks up, hang up on all the others (no promises)

Other types of phones, especially AI internal phones :)

*/

// Bitflags for whether or not an attempt to relay something through a phone failed, and how it failed; mostly used for voltrons/vapes
#define PHONE_RELAY_NO_PHONECALL (1<<1)
#define PHONE_RELAY_NO_TARGETS (1<<2)
#define PHONE_RELAY_SUCCESS (1<<3)


/datum/phone
	var/atom/holder = null /// the atom we belong to; you'll have to define a new var for your specific atom type if you need to
	var/phoneName = null /// This is the name the user will see when we're displayed in a contact list
	var/phoneNumber = null /// unique identifier for our phone. doubles as a way to directly try and contact a phone
	var/formattedPhoneNumber = null /// string version of phone number in xxx-xxxx format. mostly just for displaying to users
	var/static/phoneNumberHash[9999999] /// stores all phone numbers in every phone datum; used for quickly accessing phone number and associated phone
	var/phoneCallType = /datum/phonecall /// override var for your phone datum to generate a different phonecall datum

	var/unlisted = FALSE
	var/maxConnected = 1 /// limit of how many contacts can be in a phonecall with us, not including us
	var/prioritizeOurMax = FALSE /// if TRUE other phones will ignore their maxConnected when they try to join a phonecall we're hosting

	var/dialledNumber = "" /// used by the dialpad to store user input
	var/static/keyTones = list( /// Keys and their tone sound .oggs; also doubles as input validation.
		"0" = 'sound/machines/phones/DTMF/DTMF-0.ogg',
		"1" = 'sound/machines/phones/DTMF/DTMF-1.ogg',
		"2" = 'sound/machines/phones/DTMF/DTMF-2.ogg',
		"3" = 'sound/machines/phones/DTMF/DTMF-3.ogg',
		"4" = 'sound/machines/phones/DTMF/DTMF-4.ogg',
		"5" = 'sound/machines/phones/DTMF/DTMF-5.ogg',
		"6" = 'sound/machines/phones/DTMF/DTMF-6.ogg',
		"7" = 'sound/machines/phones/DTMF/DTMF-7.ogg',
		"8" = 'sound/machines/phones/DTMF/DTMF-8.ogg',
		"9" = 'sound/machines/phones/DTMF/DTMF-9.ogg',
		"#" = 'sound/machines/phones/DTMF/DTMF-pound.ogg',
		"âˆ—" = 'sound/machines/phones/DTMF/DTMF-star.ogg'
	) // DTMF tones generated by Audacity
	var/lastDial = 0 /// used for dialpad cooldown

	var/datum/phonecall/incomingCall /// who's calling us???
	var/datum/phonecall/currentPhoneCall = null
	var/startingCall = FALSE /// are we currently trying to make a phone call?

	var/canVoltron = FALSE
	var/canVape = FALSE // you better make this true when possible, dweeb
	var/canTalkAcrossZLevels = FALSE


	var/elementSettings = list( /// List of vars are for enabling or disabling certain elements of the UI, such as hangup buttons, or other things like themes
		"groupCallControl" = FALSE,
		"contactPanel" = TRUE,
		"dialPad" = TRUE,
		"dialScreen" = TRUE,
		"syndicate" = FALSE // do we got the menacing red color??
	)

	/// Default sounds, override at your leisure
	var/sound/toneBusy = 'sound/machines/phones/phone_busy.ogg'
	var/sound/diallingSound = 'sound/machines/phones/dial.ogg'
	var/sound/outgoingRing = "sound/machines/phones/ring_outgoing.ogg"
	var/sound/dialTone = "sound/machines/phones/dialtone.ogg" // https://freesound.org/people/ramicio/sounds/158427/

	/// Call as New(src)
	New(var/atom/creator)
		..()
		holder = creator // phoneName should be assigned elsewhere or by just overriding the var
		generatePhoneNumber()
		START_TRACKING

	disposing()
		STOP_TRACKING
		..()



	/// Handles joining *and* inviting to phonecalls, and creating them as necessary. toCall may be a phone datum, a phone number, or a list of either or both
	proc/startPhoneCall(var/toCall, var/forceStart, var/doGroupCall = FALSE, var/manuallyDialled = FALSE)
		if(startingCall)
			return FALSE // forcestart won't work here since we can't stop currently playing dial sounds; there's a 4 second window where we can't start a new call

		if(currentPhoneCall)
			if(forceStart)
				hangUp()
			else if(!(currentPhoneCall.isGroupCall && currentPhoneCall.host == src))
				return FALSE

		if(!toCall && !forceStart)
			return FALSE // forceStart will let us start an empty call if need be, even if we don't have a target or our target is invalid

		toCall = validatePhones(toCall)

		startingCall = TRUE
		var/joinCallAttempt = tryJoinGroup(toCall, doGroupCall)
		// We're either joining an existing group call, or starting a call ourselves
		if(!isnull(joinCallAttempt)) // only null if we aren't joining a valid group call, but if we are we return whether or not it was successful
			. = joinCallAttempt ? TRUE : FALSE
		else
			if(!currentPhoneCall) // if it's not an existing call we make a new one
				currentPhoneCall = new phoneCallType(src, maxConnected, prioritizeOurMax, doGroupCall)
			. += inviteToCall(toCall)  // we can to let our proc caller know if we're successfully ringing them or not, and how many people we were able to start ringing
		if(manuallyDialled)
			handleSound(dialTone,50,0)
		SPAWN_DBG(manuallyDialled ? 3 SECONDS : 0 SECONDS) // if they auto-dialled then they already went through a short delay, dont make em wait more
			if(!.)
				callFailed()
			startingCall = FALSE
		return


	/// Handles logic for if we should join a group call when we attempt to call a single phone; if they are a group call's host, this proc will by default request to join their group call
	proc/tryJoinGroup(var/call_list, var/doGroupCall)
		. = null // We return null if the phone we're calling isn't even a host and we should move to the next step in startPhoneCall. This is redundant but helps to illustrate what we're doing
		if(islist(call_list) || doGroupCall)
			return
		var/datum/phone/target = call_list
		if(!istype(target, /datum/phone))
			return
		if(!target.currentPhoneCall?.isGroupCall)
			return
		if(target.currentPhoneCall?.host != target)
			return

		. = FALSE // FALSE and not null because by this point we're now certain on what we wanna do, which is to join this call
		var/datum/phonecall/targetCall = target.currentPhoneCall
		if(joinPhoneCall(targetCall))
			return TRUE // yay we joined the call!!!


	/// Calls either denyPhoneCall() or disconnectFromCall(); useful for if you just wanna cut all connections immediately. Also clears the dialled number
	proc/hangUp()
		incomingCall?.callDenied(src)
		disconnectFromCall()
		dialledNumber = ""
		handleSound("sound/machines/phones/remote_hangup.ogg", 30, 0)


	/// Rejects an incoming phone call and alerts the phonecall datum of this
	proc/denyPhoneCall(var/datum/phonecall/targetPhoneCall)
		incomingCall.callDenied(src)
		incomingCall = null


	/// Called when we're hosting a phone call and someone denies our invitation (very rude). Or maybe their line was just busy.
	proc/callFailed(var/datum/phone/denyingPhone) // no need to reference the phonecall when we're hosting it (if it exists), but it might be helpful to know who denied the call, if applicable
		if(currentPhoneCall?.isGroupCall)
			return
		handleSound(toneBusy,50,0)


	/// For if you wish to cancel someone's invite to your call; particularly useful for group calls
	proc/cancelInvite(var/datum/phone/target)
		if(isnull(target.incomingCall) || (target.incomingCall != currentPhoneCall)) // avoids this somehow proc'ing when both are null. somehow.
			return
		target.incomingCall = null
		target.onInviteCancelled(src)


	/// Called either when the host rescinds the invite or the phonecall is being disposed
	proc/onInviteCancelled(var/datum/phone/canceller, var/datum/phonecall/cancellingCall)
		incomingCall = null


	/// Signals to a datum/phonecall that we'd like to join the phonecall; used for accepting/answering an incoming call
	proc/joinPhoneCall(var/datum/phonecall/targetPhoneCall)
		if(currentPhoneCall)
			return
		targetPhoneCall.tryConnect(src)


	proc/answerCall()
		if(currentPhoneCall || !incomingCall)
			return //this should never happen but eh
		incomingCall.tryConnect(src)


	/// Procs whenever we successfully join a call
	proc/onJoin(var/datum/phonecall/joinedPhoneCall)
		currentPhoneCall = joinedPhoneCall
		incomingCall = null
		return


	/// Procs whenever a phone joins a call we're in
	proc/onRemoteJoin(var/datum/phone/connectedPhone)


	/// Signals to a datum/phonecall that we'd like to leave our current phonecall; aka we're hanging up
	proc/disconnectFromCall()
		currentPhoneCall?.disconnect(src)


	/// Procs whenever we're disconnected from our current call or an incoming one
	proc/onDisconnect(var/datum/phonecall/leftPhoneCall)
		currentPhoneCall = null
		incomingCall = null


	/// Procs whenever someone leaves a call we're in; NOT when they deny the call, but when they hang up
	proc/onRemoteDisconnect(var/datum/phone/disconnectedPhone)



	// Ripped straight from obj/item/proc/talk_into(), hopefully contains enough information for a wide variety of override cases
	proc/sendSpeech(mob/M as mob, text, secure, real_name, lang_id, initialText)
		if(!currentPhoneCall)
			return
		currentPhoneCall.relaySpeech(src, M, text, secure, real_name, lang_id, initialText)


	/// Called by currentPhoneCall whenever it's relaying speech to us. Override in child proc to make this actually do something
	proc/speechReceived(var/datum/phone/source, mob/M as mob, text, secure, real_name, lang_id, initialText)


	/// You need to override this in your child phone datum to actually play sound. All attempts by this datum to play sound will route through here.
	proc/handleSound(soundin, vol as num, vary, extrarange as num, pitch, ignore_flag = 0, channel = VOLUME_CHANNEL_GAME, flags = 0)
		return // Functions identically to playsound(), save for lack of source



	/// Returns a list of phone addresses that we can see in our contact list. By default will just display all phones that aren't Unlisted
	proc/getContacts()
		var/contacts = list()
		for (var/datum/phone/P in by_type[/datum/phone])
			if (P.canSee(src) && (P != src))
				contacts += P // we ask P if we can contact it
		return contacts


	/// Used by getContacts() to determine whether or not it should include this phone address in its return statement. queryingPhone for potential override usage
	proc/canSee(var/datum/phone/queryingPhone)
		. = !unlisted && !qdeled && !holder.qdeled


	/// Called by receiveInvite() to see if queryingPhone should be able to try and call us, even if it entered our phone number directly.
	proc/canCallUs(var/datum/phone/queryingPhone)
		. = !qdeled && !holder.qdeled


	/// Returns the same list as getContacts() except instead of refs its the phones' phoneName associated with phone number. Yes it's a lengthy proc name fuck you.
	proc/getContactNumberToNameList()
		var/list/L = new()
		for(var/datum/phone/contact in getContacts())
			var/textNumber = num2text(contact.phoneNumber, 7)
			L += textNumber
			L[textNumber] = contact.phoneName
		return L


	proc/tryGetPhoneFromNumber(var/number)
		if(!(number >= 1000000) || !(number <= 9999999)) // we use ! here to make triple certain it's an actual number in the valid number range even if it's null or something
			return FALSE
		return phoneNumberHash[number]


	/// Handles logic needed for inviting a target phone to a call, whether it be a group call or not
	proc/inviteToCall(var/target)
		if(!istype(target, /datum/phone) && !islist(target))
			return FALSE
		if(islist(target))
			var/list/target_list = target
			. = FALSE // we let the proc that called us know if someone was successfully invited or not
			for(var/datum/phone/targetPhone in target_list)
				if(targetPhone.receiveInvite(src, currentPhoneCall))
					currentPhoneCall.pendingMembers += target
					. = TRUE
			return
		else
			var/datum/phone/targetPhone = target
			if(targetPhone.receiveInvite(src, currentPhoneCall))
				currentPhoneCall.pendingMembers += target
				return TRUE
		return FALSE


	/// Handles logic needed for when we receive an invitation to a call. If you override, make sure it will return TRUE or FALSE if the invitation was successful or not.
	proc/receiveInvite(var/datum/phone/caller, var/datum/phonecall/pendingCall)
		if(isBusy())
			return FALSE
		if(!canCallUs(caller))
			return FALSE
		incomingCall = pendingCall
		return TRUE


	/// Call if you wanna see if the phone is busy - aka if you can try to call it or not. MUST return TRUE or FALSE
	proc/isBusy()
		. = (currentPhoneCall || incomingCall)


	ui_interact(mob/user, datum/tgui/ui)
		ui = tgui_process.try_update_ui(user, src, ui)
		if(!ui)
			ui = new(user, src, "PhoneDefault")
			ui.open()

	ui_data(mob/user)
		var/contactList = getContactNumberToNameList()
		var/list/contacts = list()
		for(var/number in contactList)
			var/name = contactList[number] // we build a list of associative lists so js can keep track of which id goes with which name
			contacts += list(list("phoneNumber" = number, "name" = name))
		. = list(
			"contactList" = contacts,
			"elementSettings" = elementSettings,
			"dialledNumber" = dialledNumber,
			"incomingCall" = !!incomingCall, // sanitize the ref out, we only let it know if
			"currentCall" = !!currentPhoneCall // we're in a call/got an incoming one or not
			)

	ui_host()
		return holder

	ui_act(action, params)
		. = ..()
		if (.)
			return
		switch(action)
			if("makeCall")
				uiMakeCall(params["target"])
			if("dialpad")
				handleDialPad(params["text"])
				. = TRUE // we wanna make the dialpad responsive!


	/// Called by ui_act() when we hit the shortcut to call a phone without having to dial their number
	proc/uiMakeCall(target)
		if(startingCall)
			return
		handleSound(diallingSound,50,0)
		startingCall = TRUE
		SPAWN_DBG(4 SECONDS)
			startingCall = FALSE
			startPhoneCall(target)

	proc/uiLeaveCall()
		disconnectFromCall()


	/// Handles dialpad input and what to do on each key press. Accepts any single valid dialpad key
	proc/handleDialPad(key)
		if((lastDial + 0.2 SECONDS) > world.time) // 0.2s because that's the length of a single key tone
			return
		lastDial = world.time
		key2SoundOutput(key)
		currentPhoneCall?.relayKeyPress(src, key)

		if((key != "CALL") && (key != "HANG")) // can't do length(key) here since APPARENTLY âˆ— isn't one character?? idfk
			dialledNumber += key
			return

		else if(!findtextEx(dialledNumber, "âˆ—") && !findtextEx(dialledNumber, "#") && (key == "CALL"))
			var/trueDialledNumber = text2num_safe(dialledNumber)
			dialledNumber = ""
			startPhoneCall(trueDialledNumber, forceStart = TRUE, manuallyDialled = TRUE) // we do this so we don't play the dialtone sound for auto-dialling, which already plays it

		else if(key == "HANG")
			dialledNumber = ""
			hangUp()

		else if(key == "CALL") // not sure how this would fail at this point but ya never know
			dialledNumber = "" // we reset it because the user hit CALL with * or # in the dialled number
			return TRUE // we return TRUE so you can continue from here by doing if(..()) or something, if you wanna use * commands or whatever, you fucking nerd. be sure to save diallednumber to a var though


	/// Attempts to play a sound based on the key the user pressed
	proc/key2SoundOutput(key)
		if(!(key in keyTones))
			return
		var/sound/tone = keyTones[key]
		handleSound(tone, 30, 0)
		return TRUE // for proc overrides if you wish to do something else when a button is successfully pressed


	/// Called whenever someone in a call we're in hits a dial button; used for any advanced commands/functions you may wanna add
	proc/receiveForeignKeyPress(source, key)


	/// Will take any input and output any valid phone datums it finds in a list; accepts lists and single vars of phone datums or phone numbers in both numerical and string form
	proc/validatePhones(var/input)
		var/toValidateList = list(input)
		var/returnList = list()
		for(var/toValidate in toValidateList)
			if(istype(toValidate, /datum/phone))
				returnList += toValidate
			else if(text2num_safe(toValidate))
				toValidate = text2num_safe(toValidate)
			if(isnum(toValidate))
				if((0 < toValidate) && (toValidate <= 9999999))
					var/target = phoneNumberHash[toValidate]
					if(target)
						returnList += target
		return returnList // lets us slap validatePhones into a for loop since it still parses empty lists


	/// Generates a unique 7 digit phone number and automatically logs it in the phone number hash
	proc/generatePhoneNumber()
		var/testNumber
		do
			testNumber = rand(1000000, 9999999) // guaranteed to never start with a 0 because that'd cause some real fuckery
		while(phoneNumberHash[testNumber]) // literally 1 in 9 million odds to get a duplicate but just in case

		phoneNumberHash[testNumber] = src
		phoneNumber = testNumber
		formattedPhoneNumber = splicetext(num2text(phoneNumber, 7), 4, 4, "-")


	/// Handles what should happen when someone vapes through us.
	/// You'll need to override this; set _buffer.my_atom to wherever you want the smoke to emerge from
	proc/onVape(var/datum/reagents/_buffer, var/obj/item/reagent_containers/vape/vape, var/mob/living/sourceMob, var/datum/phone/sourcePhone, var/turf/locOverride)
		smoke_reaction(_buffer, vape.range, get_turf(_buffer.my_atom))
		particleMaster.SpawnSystem(new /datum/particleSystem/blow_cig_smoke(holder.loc, NORTH))
		particleMaster.SpawnSystem(new /datum/particleSystem/blow_cig_smoke(holder.loc, SOUTH))
		particleMaster.SpawnSystem(new /datum/particleSystem/blow_cig_smoke(holder.loc, EAST))
		particleMaster.SpawnSystem(new /datum/particleSystem/blow_cig_smoke(holder.loc, WEST))
		logTheThing("combat", sourceMob, null, "vaped over their phone, outputting to phone datum [src], owned by [holder].")
		SPAWN_DBG(0) //vape is just the best for not annoying crowds I swear
			vape.smoke.start()
			sleep(1 SECOND)
		//Sample text for what you might wanna use for your proc override
		//boutput(user,"<span class='alert'><B>[sourceMob] blows a cloud of smoke right through the phone! What a total [pick("dork","loser","dweeb","nerd","useless piece of shit","dumbass")]!</B></span>")


	/// Handles final check for if someone can voltron to us once we've been targetted for it - checks for canVoltron already have been done by the point this is intended to be called.
	/// Returns whatever atom the person will visibly emerge from.
	proc/onVoltron(var/mob/living/sourceMob, var/obj/item/device/voltron/voltron, var/datum/phone/sourcePhone, var/isOrgan = FALSE, var/override) // isOrgan for if a mishap occured; an organ will be emerging, not a person
		if(isnull(override)) //if you called ..() with override you can still safely call ..()
			. = holder
		else
			. = override
		var/turf/sourceTurf = get_turf(sourceMob)
		var/turf/targetTurf = get_turf(.)
		if((isrestrictedz(sourceTurf.z) || isrestrictedz(targetTurf.z)) && !isOrgan)
			. = FALSE // we can shoot our organs across restricted z levels, which is a win i guess??



// Nex Note: I'm planning to implement better group management functionality in the future; I'll still need to build the UI section for it and such, so for the moment I'd advise against making group call systems
// (this is because this initial PR adding all this is already really fucking big and it isn't needed for landlines to work)
// This also means group calls may still be buggy, as nothing has yet been developed for them. But, everything is preemptively designed to work with them to make eventual implementation easier

/// Handles all the members and routing all the speech, sound, and data in a phone call
/// Be careful overriding this too much, make sure you account for other phone datums that may try to connect to this
/datum/phonecall
	var/doCustomNew = FALSE /// if you wanna override New() then set this to true; ..() will only call the parent ..() in this case
	var/disposing = FALSE

	var/phonecallID = null /// in case someone needs to refer to a specific call in a UI, we'll have a unique ID for it

	var/members = list() /// Support for 3+ contact calls! Number of connected phones is capped by maxMembers
	var/pendingMembers = list() /// sometimes it's useful to know who's being rung up but hasn't connected yet
	var/datum/phone/host = null /// who's hosting this party?!

	var/maxMembers = null /// how many people can be in this call?
	var/overrideMax = FALSE /// if true, phones will ignore their maxMembers value
	var/isGroupCall = null /// we can see our host's call max but what if they don't want to do a group call?
	var/allowJoinRequests = FALSE /// can people join without an invite?


	New(creator, max, priority, groupCall)
		..()
		initializeVars(creator, max, priority, groupCall)


	/// Override this instead of New()
	proc/initializeVars(creator, max, priority, groupCall)
		host = creator
		maxMembers = max
		overrideMax = priority
		isGroupCall = groupCall
		phonecallID = format_net_id("\ref[src]")


	disposing()
		disposing = TRUE
		for(var/datum/phone/pendingContact in pendingMembers)
			pendingContact.onInviteCancelled(cancellingCall = src)
			pendingMembers -= pendingContact
		for(var/datum/phone/contact in members)
			disconnect(contact)
		disconnect(host)
		..()



	/// Handles logic for when a phone agrees to an invitation to this call
	proc/tryConnect(var/datum/phone/target)
		if(length(members) > maxMembers)
			return FALSE
		if((length(members) > target.maxConnected) && !overrideMax)
			return FALSE
		if(target in members)
			return FALSE
		if((src != target.currentPhoneCall) && !isnull(target.currentPhoneCall))
			return FALSE
		members += target
		pendingMembers -= target
		target.onJoin(src)
		for(var/datum/phone/member in members)
			member.onRemoteJoin(target)
		host.onRemoteJoin(target)
		return TRUE


	/// Handles logic for when a phone in pendingMembers denies our call; we assume they've already set their incomingCall to null
	proc/callDenied(var/datum/phone/denyingPhone)
		host.callFailed(denyingPhone) // only the host can invite so we let them know their invitation failed
		pendingMembers -= denyingPhone



	/// Handles logic for what we should do when a phone wants to disconnect from the call
	proc/disconnect(var/datum/phone/target)
		if(isnull(target) || (!(target in members) && target != host))
			return
		target.onDisconnect(src) // we let them know what /phonecall datum is calling this proc, just in case an override wants to use it
		if(host == target)
			host = null // we set this now so that when we call dispose() it won't try to disconnect the host again in a loop
			for(var/datum/phone/member in members)
				member.onRemoteDisconnect(host) // we only wanna play this once per person
			dispose() // the phonecall can't exist if we stop hosting!
		else
			members -= target
			if(!disposing)
				for(var/datum/phone/member in members)
					member.onRemoteDisconnect(target)
				host.onRemoteDisconnect(target)


	/// Returns a list of all members of a call, including its host
	proc/getMembers()
		var/memberList = list()
		memberList += members
		memberList += host
		return memberList



	/// Relays incoming speech from call members to the rest of the members in the call
	proc/relaySpeech(var/datum/phone/source, mob/M as mob, text, secure, real_name, lang_id, initialText)
		var/recipients = getMembers()
		recipients -= source
		for(var/datum/phone/target in recipients)
			target.speechReceived(source, M, text, secure, real_name, lang_id, initialText)


	/// Handles relaying key presses to other members of a call. By default this has no effect, but may find use in machine-linked phone systems
	proc/relayKeyPress(var/datum/phone/source, var/key)
		var/recipients = list()
		recipients += getMembers()
		recipients -= source
		for(var/datum/phone/target in recipients)
			target.receiveForeignKeyPress(source, key)


	/// The coolest proc, responsible for routing the reagents to the various onVape() procs for phone members where canVape is true.
	/// Returns the # of phones successfully vaped into
	proc/relayVape(var/obj/item/reagent_containers/vape/vape, var/mob/living/sourceMob, var/datum/phone/sourcePhone) // doing this to group calls is a terrible idea :)
		. = 0 // how many people did we prank with our sick vape??
		if((sourcePhone != host) && !(sourcePhone in members))
			return
		var/recipients = getMembers()
		recipients -= sourcePhone
		for(var/datum/phone/target in recipients)
			if(!target.canVape)
				recipients -= target

		if(!length(recipients))
			return

		vape.reagents.trans_to(sourceMob, 5)

		var/amountToTransfer = 5 / length(recipients)

		for(var/datum/phone/target in recipients)
			var/datum/reagents/buffer = new /datum/reagents(5)
			buffer.my_atom = vape // honestly just copy/pasted this since im not too familiar with reagent code oops
			vape.reagents.trans_to_direct(buffer, amountToTransfer)
			target.onVape(buffer, vape, sourceMob, sourcePhone)
			.++


	/// Attempts to find a valid voltron target from all members of a call
	/// Will return the target phone datum if successful in list index 1, as well as the target phone for an organ to fly out of if a Mishap occurs in index 2
	proc/getVoltronTarget(var/mob/user, var/obj/item/device/voltron/voltron, var/datum/phone/source)
		if((source != host) && !(source in members))
			return
		var/recipients = getMembers()
		recipients -= source
		for(var/datum/phone/target in recipients)
			if(!target.canVoltron)
				recipients -= target
		if(!length(recipients))
			return
		var/returnList = list()
		var/datum/phone/target = pick(recipients)
		returnList += target

		if(prob(5) && (length(recipients) > 1)) // try not to roll a nat 1, nerd. at least in group calls.
			recipients -= target
			returnList += pick(recipients) // 2nd index indicates which phone part of the voltron nerd's body is going to
		else
			returnList += FALSE

		return returnList
